# Centralised Logging & Monitoring – README

## Least-Privilege SQL Server Environment

### Permissions Constraints

**Allowed Operations:**
- ✅ `DELETE`
- ✅ `INSERT`

**Prohibited Operations:**
- ❌ `CREATE TABLE`
- ❌ `TRUNCATE`

Configure seeds correctly so dbt never attempts `CREATE` or `TRUNCATE`, and instead performs:

```sql
DELETE FROM Ref.<table>;
INSERT INTO Ref.<table> (...)
```

---

## What dbt Normally Does with Seeds

### Default Behavior

By default, dbt tries to:

1. `DROP TABLE`
2. `CREATE TABLE`
3. `INSERT` rows

**You cannot allow steps 1 or 2.**

### With Full Refresh Disabled

When you disable full refresh and disable create, dbt switches to:

1. `TRUNCATE TABLE`
2. `INSERT` rows

**But you also cannot allow `TRUNCATE`.**

### Required Pattern

So we need to force dbt to:

1. `DELETE FROM table`
2. `INSERT` rows

**This is the only pattern that works with your permissions.**

---

## Step 1: Configure Seeds to Use DELETE Instead of TRUNCATE

In `dbt_project.yml`:

```yaml
seeds:
  crds1-reconciliation-dbt:
    +schema: ref
    +materialized: seed

    # Prevent dbt from trying to recreate the table
    +full_refresh: false

    # Force DELETE instead of TRUNCATE
    +delete_before_insert: true

    # Avoid quoting issues in SQL Server
    +quote_columns: false

    bian_mappings:
      +alias: bian_mappings

    bian_reconciliation_types:
      +alias: bian_reconciliation_types
```

### Configuration Explained

- ✅ **`+full_refresh: false`**  
  Stops dbt from issuing `CREATE TABLE`.

- ✅ **`+delete_before_insert: true`**  
  This is the **key setting** — it forces dbt to run:
  ```sql
  DELETE FROM Ref.bian_mappings;
  INSERT INTO Ref.bian_mappings (...)
  ```
  instead of `TRUNCATE`.

- ✅ **`+materialized: seed`**  
  Ensures dbt uses the seed loader, not a model.

---

## Step 2: Ensure the Tables Already Exist

You must have these tables created manually (or by DBA):

```sql
Ref.bian_mappings
Ref.bian_reconciliation_types
```

**dbt will not create them.**

---

## Step 3: Run the Seeds

```bash
dbt seed --target dev
```

dbt will now:

```sql
DELETE FROM Ref.bian_mappings;
INSERT INTO Ref.bian_mappings (...);

DELETE FROM Ref.bian_reconciliation_types;
INSERT INTO Ref.bian_reconciliation_types (...);
```

**No `CREATE`, no `TRUNCATE`.**

---

## Step 4: Use Them Normally in dbt

```jinja
select *
from {{ ref('bian_mappings') }}
```

---

## Why This Pattern Is Perfect for Your Environment

- ✅ Works with read + write only permissions
- ✅ Avoids `CREATE TABLE`
- ✅ Avoids `TRUNCATE`
- ✅ Avoids `DROP`
- ✅ Keeps seeds as the single source of truth
- ✅ Allows dbt to manage data without managing schema
- ✅ Fully compatible with SQL Server adapter

---

## Creating Seed-Driven, Metadata-Driven Reconciliation Models

This approach is fully aligned with:

- ✅ Your BIAN mappings (including `is_key`)
- ✅ Your reconciliation types
- ✅ Your least-privilege SQL Server environment
- ✅ Your dynamic staging naming macro
- ✅ Your reconciliation macros already implemented

---

## GitHub Copilot Prompt: Generate Seed-Driven Dynamic Reconciliation Models

### Context

You are assisting with generating the full dynamic reconciliation layer in dbt. All reconciliation logic must be driven entirely from the seed tables:

- `Ref.bian_mappings`
- `Ref.bian_reconciliation_types`

These tables already exist in SQL Server and dbt seeds only `DELETE + INSERT` into them. **Do not create or reference any seed as a model; always use `ref()`.**

---

### Goal 1: Dynamic Reconciliation Models

Generate reconciliation models that dynamically compare source and target systems using metadata from the seeds. The reconciliation must be driven by:

- Composite primary keys defined by `is_key = 'Y'` in `bian_mappings`
- Attribute mappings from `bian_mappings`
- Join direction, join type, and inclusion rules from `bian_reconciliation_types`
- Staging model names generated by `staging_name(system, domain, entity)`

---

### Inputs Available

**Seeds:**
```jinja
{{ ref('bian_mappings') }}
{{ ref('bian_reconciliation_types') }}
```

**Macros already implemented:**
- `staging_name()`
- `reconciliation_join_conditions()`
- `reconciliation_select()`
- `reconciliation_exception_select()`
- `reconciliation_summary()`

**Staging models follow:**
- `stg_<system>_<domain>_<entity>` (domain required only for DSL)

---

### What to Generate

#### 1. Reconciliation Model Template

- **File:** `models/reconciliation/<domain>/<entity>.sql`
- **Config alias:** `recon_<domain>_<entity>`
- **Steps:**
  1. Read reconciliation type row for this domain/entity
  2. Read all mapping rows for this domain/entity
  3. Extract composite keys where `is_key = 'Y'`
  4. Build join using `reconciliation_join_conditions()`
  5. Call `reconciliation_select()` to produce:
     - Primary key columns
     - `source_*` and `target_*` columns
     - `is_<attribute>_match` flags
     - `mismatch_columns` summary
     - `match_status`
     - Join metadata (direction, join_type, include_missing_*)
     - Audit fields

#### 2. Exception Model Template

- **File:** `models/reconciliation/<domain>/<entity>_exceptions.sql`
- **Config alias:** `recon_<domain>_<entity>_exceptions`
- Use `reconciliation_exception_select()`

#### 3. Summary Model

- **File:** `models/reconciliation/summary/recon_summary_all_entities.sql`
- **Config alias:** `recon_summary_all_entities`
- Use `reconciliation_summary()`

#### 4. Example Reconciliation Models

- Generate at least two examples using real domains/entities from the seeds

#### 5. Tests

- Unique tests on composite keys for both source and target
- No duplicate matches
- Seed validation tests:
  - `bian_mappings`: no nulls in key columns, valid `is_key` values
  - `bian_reconciliation_types`: valid `join_type`, `direction`, flags

#### 6. Documentation

- Document how composite keys are derived from `is_key`
- Document how reconciliation types drive join logic
- Document the reconciliation model pattern
- Document exception and summary models
- Document seed structures

---

### Rules

- ❌ No hard-coded join logic; all joins must be generated from seeds
- ❌ No warehouse-specific SQL
- ✅ Always reference seeds using `ref()`
- ✅ Always reference staging models using `ref(staging_name(...))`
- ✅ Domain is required only for DSL; other systems ignore domain in staging names
- ✅ All reconciliation SQL must be generated through macros

#### Deliverables for Goal 1

Proceed to generate:

1. Reconciliation model template
2. Exception model template
3. Summary model
4. Example models
5. Tests
6. Documentation blocks

---

### Goal 2: Generate Comprehensive Test Suite from Seeds

Generate a complete dbt test suite driven entirely by seed metadata. Tests must validate both the seed tables themselves and the reconciliation models generated from them.

#### Tests to Generate

**1. Seed Validation Tests**

For `bian_mappings`:
- No nulls in required columns: `bian_service_domain`, `bian_business_object`, `bian_attribute`, `sor_system`, `sor_attribute`, `is_key`
- `is_key` must be either `'Y'` or `'N'`
- No duplicate rows for (domain, entity, attribute)

For `bian_reconciliation_types`:
- `join_type` must be one of: `left`, `full_outer`
- `direction` must be one of: `one_way_left`, `both_ways`
- `include_missing_source` and `include_missing_target` must be Y/N
- No duplicate rows for (domain, source_system, target_system)

**2. Dynamic Tests for Reconciliation Models**

For each (domain, entity) pair:
- Unique test on composite primary keys (from `is_key = 'Y'`)
- Unique test on reconciliation output primary key
- No duplicate matches
- `match_status` must be one of: `matched`, `mismatch`, `missing_in_source`, `missing_in_target`
- `mismatch_columns` must be null when `match_status = 'matched'`

**3. Exception Model Tests**

- All rows must have `match_status` in: `mismatch`, `missing_in_source`, `missing_in_target`
- No matched rows allowed

**4. Summary Model Tests**

- Row counts must equal sum of reconciliation model row counts
- All domains/entities must appear exactly once

#### Rules for Goal 2

- ❌ No hard-coded column names except seed column names
- ✅ All tests must be generated dynamically from seed metadata
- ✅ Use dbt generic tests where possible
- ✅ Use custom tests where needed (e.g., composite key uniqueness)
- ✅ Place tests in `tests/reconciliation/<domain>/<entity>.yml`

#### Deliverables for Goal 2

- Seed test YAML files
- Reconciliation model test YAML files
- Exception model test YAML files
- Summary model test YAML
- Any custom test macros required
